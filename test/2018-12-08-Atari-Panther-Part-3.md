---
layout: post
title: The Atari Panther - Part 3 - Features
---

Welcome back to this series of articles. In this third part we will review critically the declared features.

<table style="width:75%;font-size:65%;margin:auto;text-align:center;">
  <tr>
    <td><img src="{{ site.url }}/images/atari-panther-2/image_0.png"></td>
  </tr>
  <tr>
    <td>A <a href="https://imgur.com/a/lbdFc">3D rendering</a> of the Atari Panther</td>
  </tr>
</table>

Articles:
* [Part 1 - The history](../Atari-Panther-Part-1/)
* [Part 2 - The hardware](../Atari-Panther-Part-2/)
* [Part 3 - Specifications](../Atari-Panther-Part-3/)

# Declared features

While the Panther was in development, Atari started a press campaign and communicated these features.

<table style="width:50%;font-size:65%;margin:auto;text-align:center;">
  <tr>
    <td><img style="vertical-align:middle;" src="{{ site.url }}/images/atari-panther-3/image_7.png"></td>
  </tr>
  <tr>
    <td>Specifications declared to the press (from [Internet Archive](https://web.archive.org/web/20031207084119/http://www.atari-explorer.com:80/Panther-Spec.htm))</td>
  </tr>
</table>

As usual in these cases, while true, these figures don’t quite represent the truth. Let’s see why.

## '7860 colors/screen'
This figure comes from the idea of changing all the 32 entries of the CLUT at every visible scanline. Indeed, in NTSC (including the over-scan area) there are 240 visible lines and a simple multiplication gives the expected result: 240 * 32 = 7860 colors.

To have an idea of how effective this technique can be, take a look to the following image. It has up to 16 colors per scanline but the colors are modified across the screen.

<table style="width:50%;font-size:65%;margin:auto;text-align:center;">
  <tr>
    <td><img style="vertical-align:middle;" src="{{ site.url }}/images/atari-panther-3/scavengers_oni_step_final.png"></td>
  </tr>
  <tr>
    <td>Amiga dynamic hires image. Source <a href="http://eab.abime.net/showthread.php?t=86837">EAB</a> </td>
  </tr>
</table>

While doable and effective for static images, this technique becomes unrealistic for animated images typical on video games.

This can be explained with a simplified example. Let's imagine a screen where a red car is positioned on the top half and a yellow one on the bottom half.
The 32 colors palette contains both the reds and the yellows plus all the other needed colors. For example, the palette could contain 8 shades of red, 8 shades of yellow and 16 other colors.

<table style="width:50%;font-size:65%;margin:auto;text-align:center;">
  <tr>
    <td><img style="vertical-align:middle;" src="{{ site.url }}/images/atari-panther-3/cars1.png"></td>
  </tr>
  <tr>
    <td>Common CLUT</td>
  </tr>
</table>

Now a smart programmer decides to split the screen in two.
On the top half a red 'oriented' palette of 32 colors is used. On the bottom half a yellow one is used.
This allows for 16 shades of red on the top and 16 shades of yellow on the bottom.

<table style="width:50%;font-size:65%;margin:auto;text-align:center;">
  <tr>
    <td><img style="vertical-align:middle;" src="{{ site.url }}/images/atari-panther-3/cars2.png"></td>
  </tr>
  <tr>
    <td>Screen split in two and two optimized CLUTs</td>
  </tr>
</table>

This is great, but what happens when the yellow car goes up and crosses the middle of the screen?
The top of the yellow car becomes red because uses the upper palette.

<table style="width:50%;font-size:65%;margin:auto;text-align:center;">
  <tr>
    <td><img style="vertical-align:middle;" src="{{ site.url }}/images/atari-panther-3/cars3.png"></td>
  </tr>
  <tr>
    <td>Artifact</td>
  </tr>
</table>

This basic example shows that, if you don't have full control on how the graphics move across the screen then it is extremely difficult to apply this technique.

It is possible to imagine a more elaborated setups and for sure the dynamic CLUT technique can improve colorfulness but, in any case, the advertised 7860 colors on screen are not obtainable during actual game action.

## 'Genlock option'

This seems simply false.

A Genlock is a device that, when connected to a computer, allows to superimpose the graphic generated by the computer on top of another video source.

The Commodore Amiga and some MSX2 computers are some of the few home computers designed to work with a Genlock. Genlocks were also used in the arcades during the laserdisc era.

<table style="width:70%;font-size:65%;margin:auto;text-align:center;">
  <tr>
    <td>{% include youtube.html id="lSYcceu_H_w" style="vertical-align:middle;" width="100%" height="200%" %}</td>
  </tr>
  <tr>
    <td>Sega Astron Belt</td>
  </tr>
</table>

The computer/console has to be designed to work with a Genlock.
* First, the computer has to signal on a pin when a pixel is transparent. In this way, the Genlock knows when to show the other picture.
* Second, the two devices needs to have a common pixel clock. For this reason, the computer has an input pin where it can accept an external pixel clock.

The problem with the Panther is that the schematics of the dev kit show that while the needed pins are present at the video connector, they are not connected (see page 5 of the console schematics).

<table style="width:50%;font-size:65%;margin:auto;text-align:center;">
  <tr>
    <td><img style="vertical-align:middle;" src="{{ site.url }}/images/atari-panther-3/video-connector.png"></td>
  </tr>
  <tr>
    <td>Video connector (from the <a href="https://www.chzsoft.de/asic-web/console.pdf">console schematics</a>)</td>
  </tr>
</table>

Also the schematics of the GameShifter chip seems to prove this.
The RGB DACs pixel clock is controlled by signal C2 (page 10 of the GS schematics). As visible at page 27, signal C2 in not connected to any pin. Indeed, signal C2 is generated inside the chip from the input pin SC and is synchronous to signal C1.

<table style="width:70%;font-size:65%;margin:auto;text-align:center;">
  <tr>
    <td><img style="vertical-align:middle;" src="{{ site.url }}/images/atari-panther-3/gates1.png"></td>
  </tr>
  <tr>
    <td>Signal C2 generation</td>
  </tr>
</table>

Signal SC is the 16 Mhz clock and, as consequence, there is no way to control it from a Genlock.

## '32 Mhz, 32 bit object oriented, graphics processor'
It is true that the Panther has a 32 Mhz crystal on the motherboard and a 32 bit data bus. Anyway, 1) some parts use only 16 bit 2) none of the parts run at 32Mhz, some run at 16 Mhz, some at 8 Mhz or even 4 Mhz. Anyway this is just marketing, bits and Mhz are not indicative of the performance without looking at the whole architecture.

## 'About 2000 sprites can be displayed simultaneously'
This figure comes from the footprint of a Bitmap Object which is 16 bytes long. By filling all the SRAM available with Bitmap Object definitions, it is possible to store 32 * 1024 / 16 = 2048 Bitmap Object definitions.
But, can they be displayed? On a NTSC system there are 200 lines. This means about 2048 / 200 = 10 sprites per line. Ten or eleven sprites per line is absolutely within the capabilities of the console.
So, yes, technically it is a true statement but it tells nothing about the real capabilities. Indeed, sprites 1 pixel tall are quite useless.

Let's try to organize the sprites in another way. We can use 16 x 16 pixels sprites and put them in a grid. When the screen is full we start again creating a new layer. Horizontally we can fit 320/16 = 20 sprites. Vertically we can fit 240/16 = 15 sprites.
This means 20*15 = 300 sprites per layer. This gives us 2000/300 = 6.67 layers on screen.

Every Bitmap Object needs 12 mclks to be processed (6 SRAM accesses) and, for a 16 colors sprite, 4 mclks (1 ROM access) every 4 pixels fetched. In total, this is 12+4*4 = 28 mclks for each sprite on a given scanline. On a scanline (64 us) there are about 1024 mclks. Therefore, 1024/28 = 37 sprites per scanline, or 37/20 = 1.8 layers per scanline.

This is a bad news, only 1.8 layers can be displayed instead of the wanted 6.67 layers. It is evident that the hardware far away from being capable of displaying 2000 'meaningful' sprites.

## 'Pixel programmable interrupt'
The Object Processor has an 'instruction' that can generate an interrupt for the CPU at a given scanline. Anyway, it is not possible to specify the x position. A more correct statement would have been "Scanline programmable interrupt".

## 'Fast hardware addition for object manipulation'
The Object Processor has an 'instruction' that allows to add a constant to value present on a given memory address. While useful to create self-modifying Object lists, this hardly communicates a performance gain compared to the competition.

# Actual performance

These specifications raise more questions than they answer. Then, what can we expect from the Panther?

# Closing

...
